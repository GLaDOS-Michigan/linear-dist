{
  "InitImpliesMonotonicityInv": 
    [ 
      "lemma InitImpliesMonotonicityInv(c: Constants, v: Variables)",
      "  requires Init(c, v)",
      "  ensures MonotonicityInv(c, v)",
      "{}"
    ],
  "InitImpliesMessageInvHeader":
    [
      "lemma InitImpliesMessageInv(c: Constants, v: Variables)",
      "  requires Init(c, v)",
      "  ensures MessageInv(c, v)",
      "{",
      "  InitImpliesValidVariables(c, v);"
    ],
  "MonotonicityInvInductive":
    [
      "lemma MonotonicityInvInductive(c: Constants, v: Variables, v': Variables)",
      "  requires MonotonicityInv(c, v)",
      "  requires Next(c, v, v')",
      "  ensures MonotonicityInv(c, v')",
      "{",
      "  VariableNextProperties(c, v, v');",
      "}"
    ],
  "MessageInvInductiveHeader":
    [
      "lemma MessageInvInductive(c: Constants, v: Variables, v': Variables)",
      "  requires MessageInv(c, v)",
      "  requires Next(c, v, v')",
      "  ensures MessageInv(c, v')"
    ],
  "NetworkModule":
    [
      "module Network {",
      "  import opened Types",
      "",
      "  datatype Variables = Variables(sentMsgs:set<Message>)",
      "",
      "  ghost predicate Init(v: Variables) {",
      "    && v.sentMsgs == {}",
      "  }",
      "",
      "  ghost predicate Next(v: Variables, v': Variables, msgOps: MessageOps)",
      "  {",
      "    && (msgOps.recv.Some? ==> msgOps.recv.value in v.sentMsgs)",
      "    && v'.sentMsgs ==",
      "      v.sentMsgs + if msgOps.send.None? then {} else { msgOps.send.value }",
      "  }",
      "}  // end module Network"
    ],
  "DatatypeVariables":
    [
      "datatype Variables = Variables(",
      "  history: seq<Hosts>,",
      "  network: Network.Variables",
      ") {",
      "",
      "  ghost predicate ValidHistoryIdx(i: int) {",
      "    0 <= i < |history|",
      "  }",
      "",
      "  ghost predicate ValidHistoryIdxStrict(i: int) {",
      "    0 <= i < |history|-1",
      "  }",
      "",
      "  ghost predicate WF(c: Constants) {",
      "    && c.WF()",
      "    && 0 < |history|",
      "    && (forall i | ValidHistoryIdx(i) :: history[i].WF(c))",
      "  }",
      "",
      "  ghost function Last() : (h: Hosts)",
      "    requires 0 < |history|",
      "    ensures h == history[|history|-1]",
      "    ensures h == History(|history|-1)",
      " {",
      "    UtilitiesLibrary.Last(history)",
      "  }",
      "",
      "  ghost function History(i: int) : (h: Hosts)",
      "    requires ValidHistoryIdx(i)",
      "    ensures h == history[i]",
      "  {",
      "    history[i]",
      "  }",
      "}  // end datatype Variables"
    ],
  "InitHostsHeader":
    [
      "ghost predicate InitHosts(c: Constants, h: Hosts)",
      "  requires h.WF(c)",
      "{"
    ],
  "Init":
    [
      "ghost predicate Init(c: Constants, v: Variables)",
      "{",
      "  && v.WF(c)",
      " && |v.history| == 1",
      "  && InitHosts(c, v.History(0))",
      "  && Network.Init(v.network)",
      "}"
    ],
  "NextStepHeader":
    [
      "ghost predicate NextStep(c: Constants, h: Hosts, h': Hosts, n: Network.Variables, n': Network.Variables, step: Step)",
      "  requires h.WF(c) && h'.WF(c)",
      "{",
      "  && Network.Next(n, n', step.msgOps)",
      "  && match step"
    ],
  "Next":
    [
      "ghost predicate Next(c: Constants, v: Variables, v': Variables)",
      "{",
      "  && v.WF(c)",
      "  && v'.WF(c)",
      "  && IsSeqExtension(v.history, v'.history)",
      "  && exists step :: NextStep(c, v.Last(), v'.Last(), v.network, v'.network, step)",
      "}"
    ],
  "VariablePropertiesSeperator":
    [
      "/***************************************************************************************",
      "*                                Variable properties                                   *",
      "***************************************************************************************/"
    ],
  "ValidHistory":
    [
      "ghost predicate {:opaque} ValidHistory(c: Constants, v: Variables)",
      "  requires v.WF(c)",
      "{",
      "  InitHosts(c, v.History(0))",
      "}"
    ],
  "ValidVariables":
    [  
      "// Bundle of Variable properties",
      "ghost predicate ValidVariables(c: Constants, v: Variables)",
      "  requires v.WF(c)",
      "{",
      "  && ValidHistory(c, v)",
      "}"
    ],
  "InitImpliesValidVariables":
    [
      "lemma InitImpliesValidVariables(c: Constants, v: Variables)",
      "  requires Init(c, v)",
      "  ensures ValidHistory(c, v)",
      "{",
      "  reveal_ValidHistory();",
      "}"
    ],
  "InvNextValidVariables":
    [
      "lemma InvNextValidVariables(c: Constants, v: Variables, v': Variables)",
      "  requires v.WF(c)",
      "  requires ValidHistory(c, v)",
      "  requires Next(c, v, v')",
      "  ensures ValidHistory(c, v')",
      "{",
      "  reveal_ValidHistory();",
      "  VariableNextProperties(c, v, v');",
      "}"
    ],
  "VariableNextProperties":
    [
      "lemma VariableNextProperties(c: Constants, v: Variables, v': Variables)", 
      "  requires v.WF(c)",
      "  requires Next(c, v, v')",
      "  ensures 1 < |v'.history|",
      "  ensures |v.history| == |v'.history| - 1",
      "  ensures v.Last() == v.History(|v'.history|-2) == v'.History(|v'.history|-2)",
      "  ensures forall i | 0 <= i < |v'.history|-1 :: v.History(i) == v'.History(i)",
      "{",
      "  assert 0 < |v.history|;",
      "  assert 1 < |v'.history|;",
      "}"
    ],
    "AuxProofsSeparator":
    [
      "/***************************************************************************************",
      "*                                     Aux Proofs                                       *",
      "***************************************************************************************/"
    ],
    "UniqueKeyInFlight":
    [
      "ghost predicate UniqueKeyInFlight(c: Constants, v: Variables, k: UniqueKey)",
      "requires v.WF(c)",
      "{",
      "  exists msg :: KeyInFlightByMessage(c, v, msg, k)",
      "}"
    ],
    "DefinitionsSeparator":
    [
      "/***************************************************************************************",
      "*                                     Definitions                                       *",
      "***************************************************************************************/"
    ],
    "InvariantsSeparator":
    [
      "/***************************************************************************************",
      "*                                     Invariants                                       *",
      "***************************************************************************************/"
    ]
}